<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Troll Maze - Stop at Junctions</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            touch-action: none; 
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            pointer-events: none; 
            z-index: 10;
        }

        #timer {
            font-size: 28px;
            font-weight: bold;
            color: #f1c40f;
            text-shadow: 2px 2px 0 #000;
        }

        #hint {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 5px;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 4px solid #fff;
            border-radius: 8px;
            background: #000;
        }

        canvas {
            display: block;
        }

        #msg-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.85);
            font-size: 24px;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            display: none;
            z-index: 20;
            font-weight: bold;
            color: #e74c3c;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="timer">30s</div>
        <div id="hint">Vuốt để di chuyển. Sẽ dừng tại ngã rẽ.</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="msg-overlay"></div>
    </div>

<script>
    // --- CẤU HÌNH & KHỞI TẠO ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const timerDisplay = document.getElementById('timer');
    const msgOverlay = document.getElementById('msg-overlay');

    const COLS = 21; 
    const ROWS = 21; 
    let TILE_SIZE = 0; 

    const COLORS = {
        bg: '#2c3e50',
        wall: '#34495e',
        wallBorder: '#2c3e50',
        path: '#ecf0f1',
        player: '#e67e22', 
        goal: '#2ecc71'    
    };

    let maze = []; // 1: Tường, 0: Đường
    let player = { x: 1, y: 1 };
    let goal = { x: 1, y: 1 };
    
    let isMoving = false;
    let moveInterval = null;
    let timeLeft = 30;
    let timerInterval = null;

    // --- RESPONSIVE ---
    function resize() {
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.90; 
        TILE_SIZE = Math.floor(size / COLS);
        canvas.width = TILE_SIZE * COLS;
        canvas.height = TILE_SIZE * ROWS;
        draw();
    }
    window.addEventListener('resize', resize);

    // --- TẠO MÊ CUNG (Prim's Algorithm) ---
    function generateMaze() {
        maze = [];
        for(let y=0; y<ROWS; y++) {
            let row = [];
            for(let x=0; x<COLS; x++) {
                row.push(1);
            }
            maze.push(row);
        }

        let walls = [];
        maze[1][1] = 0;
        addWalls(1, 1, walls);

        while(walls.length > 0) {
            let idx = Math.floor(Math.random() * walls.length);
            let w = walls[idx];
            walls.splice(idx, 1);

            let nx = w.x + w.dx;
            let ny = w.y + w.dy;

            if(nx > 0 && nx < COLS-1 && ny > 0 && ny < ROWS-1 && maze[ny][nx] === 1) {
                maze[w.y][w.x] = 0; 
                maze[ny][nx] = 0;   
                addWalls(nx, ny, walls);
            }
        }
        
        player = { x: 1, y: 1 };
        goal = { x: COLS - 2, y: ROWS - 2 };
        maze[goal.y][goal.x] = 0; 
    }

    function addWalls(x, y, walls) {
        if(x+2 < COLS) walls.push({x: x+1, y: y, dx: 1, dy: 0});
        if(x-2 > 0)    walls.push({x: x-1, y: y, dx: -1, dy: 0});
        if(y+2 < ROWS) walls.push({x: x, y: y+1, dx: 0, dy: 1});
        if(y-2 > 0)    walls.push({x: x, y: y-1, dx: 0, dy: -1});
    }

    // --- LOGIC DI CHUYỂN MỚI (Dừng tại ngã rẽ) ---
    function move(dx, dy) {
        if (isMoving) return;
        
        // Kiểm tra tường ngay bước đầu tiên
        if (maze[player.y + dy][player.x + dx] === 1) return;

        isMoving = true;

        moveInterval = setInterval(() => {
            let nextX = player.x + dx;
            let nextY = player.y + dy;

            // 1. Kiểm tra va chạm TƯỜNG (Dừng lại)
            if (maze[nextY][nextX] === 1) {
                clearInterval(moveInterval);
                isMoving = false;
                checkWin();
                return; // Dừng
            }

            // 2. Di chuyển nhân vật sang ô mới
            player.x = nextX;
            player.y = nextY;
            draw();

            if (player.x === goal.x && player.y === goal.y) {
                clearInterval(moveInterval);
                isMoving = false;
                checkWin();
                return;
            }

            // 3. Kiểm tra NGÃ RẼ (Intersection Check)
            // Nếu có đường rẽ ngang hông, dừng lại để người chơi chọn.
            let stopAtIntersection = false;

            if (dx !== 0) { 
                // Đang đi ngang (Trái/Phải) -> Kiểm tra xem có đường Lên hoặc Xuống không?
                // Lưu ý: maze[y][x] == 0 là đường đi
                let pathUp = maze[player.y - 1][player.x] === 0;
                let pathDown = maze[player.y + 1][player.x] === 0;
                
                if (pathUp || pathDown) stopAtIntersection = true;

            } else if (dy !== 0) { 
                // Đang đi dọc (Lên/Xuống) -> Kiểm tra xem có đường Trái hoặc Phải không?
                let pathLeft = maze[player.y][player.x - 1] === 0;
                let pathRight = maze[player.y][player.x + 1] === 0;

                if (pathLeft || pathRight) stopAtIntersection = true;
            }

            if (stopAtIntersection) {
                clearInterval(moveInterval);
                isMoving = false;
            }

        }, 40); // Tốc độ trượt (ms)
    }

    // --- INPUT ---
    document.addEventListener('keydown', (e) => {
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
        
        if (e.code === 'ArrowUp' || e.code === 'KeyW') move(0, -1);
        else if (e.code === 'ArrowDown' || e.code === 'KeyS') move(0, 1);
        else if (e.code === 'ArrowLeft' || e.code === 'KeyA') move(-1, 0);
        else if (e.code === 'ArrowRight' || e.code === 'KeyD') move(1, 0);
    });

    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); 
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, {passive: false});

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        let touchEndX = e.changedTouches[0].screenX;
        let touchEndY = e.changedTouches[0].screenY;
        handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
    }, {passive: false});

    function handleSwipe(x1, y1, x2, y2) {
        let dx = x2 - x1;
        let dy = y2 - y1;
        if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return;

        if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 1 : -1, 0);
        else move(0, dy > 0 ? 1 : -1);
    }

    // --- RENDER ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                if(maze[y][x] === 1) {
                    ctx.fillStyle = COLORS.wall;
                    ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = "#222";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = COLORS.path;
                    ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
        ctx.fillStyle = COLORS.goal;
        let p = TILE_SIZE * 0.2; 
        ctx.fillRect(goal.x*TILE_SIZE + p, goal.y*TILE_SIZE + p, TILE_SIZE - 2*p, TILE_SIZE - 2*p);

        let px = player.x * TILE_SIZE;
        let py = player.y * TILE_SIZE;
        ctx.fillStyle = COLORS.player;
        ctx.beginPath();
        ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/2.5, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(px + TILE_SIZE/2 - 4, py + TILE_SIZE/2 - 2, 3, 0, Math.PI*2);
        ctx.arc(px + TILE_SIZE/2 + 4, py + TILE_SIZE/2 - 2, 3, 0, Math.PI*2);
        ctx.fill();
    }

    // --- GAME CONTROL ---
    function checkWin() {
        if(player.x === goal.x && player.y === goal.y) {
            showMsg("THẮNG RỒI!<br>Nhưng map vẫn đổi thôi hihi");
            setTimeout(resetGame, 2000);
        }
    }
    function showMsg(html) {
        msgOverlay.innerHTML = html;
        msgOverlay.style.display = 'flex';
        setTimeout(() => { msgOverlay.style.display = 'none'; }, 1500);
    }
    function resetGame() {
        if (moveInterval) clearInterval(moveInterval);
        isMoving = false;
        generateMaze();
        resize(); 
        timeLeft = 30;
        updateTimer();
    }
    function updateTimer() {
        timerDisplay.innerText = timeLeft + "s";
        timerDisplay.style.color = timeLeft <= 5 ? "#e74c3c" : "#f1c40f";
    }
    function startTimerLoop() {
        if(timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            timeLeft--;
            updateTimer();
            if(timeLeft <= 0) {
                showMsg("HẾT GIỜ!<br>Map mới nè!");
                resetGame();
            }
        }, 1000);
    }
    resetGame();
    startTimerLoop();
</script>
</body>
</html>
